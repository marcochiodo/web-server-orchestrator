version: '3.8'

# WSO Stack Template - Use this as a template for deploying services
#
# This is a TEMPLATE file with variables (${IMAGE_TAG}, ${ROOT_DIR}, etc.)
# It gets interpolated by docker stack config before deployment
#
# Key concept: ONE template for ALL environments
# Same stack-template.yml for production, staging, and development
# Variables determine the actual configuration at deploy time
#
# Usage:
#   1. Copy this file to your project directory and rename it stack-template.yml
#   2. Replace 'myapp' with your project name
#   3. Update the image, environment variables, and volumes as needed
#   4. Deploy using docker stack config for variable interpolation:
#
# Multi-environment deployment with ONE template:
#   Production:  IMAGE_TAG=production ROOT_DIR=/srv/wso docker stack config -c stack-template.yml | docker stack deploy --compose-file - myapp
#   Staging:     IMAGE_TAG=staging ROOT_DIR=/srv/wso docker stack config -c stack-template.yml | docker stack deploy --compose-file - myapp
#   Development: IMAGE_TAG=development ROOT_DIR=/srv/wso docker stack config -c stack-template.yml | docker stack deploy --compose-file - myapp
#
# Why docker stack config?
#   docker stack deploy doesn't support variable substitution (${VAR})
#   docker stack config interpolates variables and outputs final config
#   This output is piped directly to docker stack deploy
#   No need for docker-compose dependency!

services:
  webapp:
    # Docker image with variable for tag
    # Default is 'latest' if IMAGE_TAG is not set
    # Note: Service will be named STACKNAME_webapp when deployed
    #       (e.g., "myapp_webapp" if you deploy with: docker stack deploy ... myapp)
    image: my.registry.com/myapp:${IMAGE_TAG:-latest}

    # Service deployment configuration
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
      # Uncomment to enable resource limits
      # resources:
      #   limits:
      #     cpus: '0.50'
      #     memory: 512M
      #   reservations:
      #     cpus: '0.25'
      #     memory: 256M

    # Environment variables
    # You can also use variables here for environment-specific config
    environment:
      # Example: database connection
      - DATABASE_URL=file:/data/sqlite/myapp.db
      # You can parametrize based on IMAGE_TAG or other variables
      # - NODE_ENV=${IMAGE_TAG:-production}
      # Add your application-specific environment variables here
      # - API_KEY=your-api-key

    # Volume mounts
    volumes:
      # SQLite database directory
      - type: bind
        source: ${ROOT_DIR}/data/sqlite
        target: /data/sqlite
      # Application assets directory
      - type: bind
        source: ${ROOT_DIR}/data/assets/myapp
        target: /data/assets
      # Add more volumes as needed
      # - type: bind
      #   source: ${ROOT_DIR}/data/config
      #   target: /app/config

    # Networks - must use wso-net for nginx reverse proxy
    networks:
      - wso-net

    # Healthcheck (optional but recommended)
    # healthcheck:
    #   test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:8080/health"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 3
    #   start_period: 40s

# Networks configuration
networks:
  wso-net:
    external: true
    name: wso-net

# Additional notes:
#
# 1. Nginx configuration:
#    After deploying your service, you need to configure nginx to proxy requests to it.
#
#    IMPORTANT: Service DNS naming in Docker Swarm
#    When you deploy with: docker stack deploy ... myapp
#    The service will be accessible at: http://myapp_webapp:8080
#    Format: http://STACKNAME_SERVICENAME:PORT
#
#    Example nginx configuration (/srv/wso/nginx-conf/myapp.conf):
#
#    server {
#        listen [::]:443 ssl;
#        listen 443 ssl;
#        server_name myapp.example.com;
#
#        ssl_certificate     /etc/letsencrypt/live/myapp.example.com/fullchain.pem;
#        ssl_certificate_key /etc/letsencrypt/live/myapp.example.com/privkey.pem;
#        include /etc/nginx/conf.d/ssl-common.conf;
#
#        location / {
#            # Note: Use STACKNAME_SERVICENAME format
#            proxy_pass http://myapp_webapp:8080;
#            include /etc/nginx/conf.d/proxy-common.conf;
#        }
#    }
#
#    See examples/nginx-proxy.conf for a more complete example
#
# 2. SSL Certificate generation:
#    /srv/wso/scripts/certbot-gen.sh myapp.example.com
#
# 3. Reload nginx:
#    /srv/wso/scripts/nginx-reload.sh
#
# 4. Updating the service:
#    Simply modify this template and redeploy:
#    IMAGE_TAG=production ROOT_DIR=/srv/wso docker stack config -c stack-template.yml | docker stack deploy --compose-file - myapp
#
# 5. Viewing logs:
#    docker service logs myapp_webapp
#
# 6. Removing the service:
#    docker stack rm myapp
#
# 7. Advanced: Using additional variables:
#    You can parametrize any field in the template:
#    IMAGE_TAG=v1.2.3 REPLICAS=3 ROOT_DIR=/srv/wso docker stack config -c stack-template.yml | docker stack deploy --compose-file - myapp
#
#    Example with replicas variable in your template:
#    deploy:
#      replicas: ${REPLICAS:-1}
#
# 8. Version control:
#    Commit stack-template.yml to git (it's the source of truth)
#    Never commit interpolated files (they contain environment-specific values)
