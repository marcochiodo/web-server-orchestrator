#!/bin/sh
set -eu

# WSO Manifest-based Deployment System v2.0
# Deploys services using YAML manifest with embedded files and host secrets
#
# Usage:
#   wso-deploy <path-to-manifest.yml>
#   wso-deploy - < manifest.yml
#   cat manifest.yml | wso-deploy -
#
# Manifest format: see examples/wso-deploy.yml

# =============================================================================
# WSO Paths (hardcoded)
# =============================================================================

readonly WSO_LIB="/usr/lib/wso"
readonly WSO_DATA="/var/lib/wso"
readonly WSO_ETC="/etc/wso"
readonly DATA_DIR="${WSO_DATA}/data"
readonly NGINX_CONF_DIR="${WSO_DATA}/nginx"
readonly CERT_DIR="${WSO_DATA}/letsencrypt"
readonly ACME_DIR="${WSO_DATA}/acme-challenge"
readonly DEFAULT_DATA_UID=1000

# =============================================================================
# Utilities
# =============================================================================

log() {
    printf "[WSO] %s\n" "$*"
}

error() {
    printf "[WSO ERROR] %s\n" "$*" >&2
}

die() {
    error "$@"
    exit 1
}

check_yq() {
    if ! command -v yq >/dev/null 2>&1; then
        die "yq is not installed. Install with: sudo dnf install yq"
    fi

    # Detect yq version (Go vs Python)
    if yq --help 2>&1 | grep -q "eval"; then
        YQ_TYPE="go"
    else
        YQ_TYPE="python"
    fi
}

# =============================================================================
# Setup
# =============================================================================

if [ $# -lt 1 ]; then
    cat >&2 <<EOF
Usage: $0 <path-to-manifest.yml>
   Or: $0 - < manifest.yml

Examples:
  $0 /tmp/deploy.yml
  cat deploy.yml | $0 -
EOF
    exit 1
fi

check_yq

MANIFEST_PATH="$1"
shift

# =============================================================================
# Read Manifest
# =============================================================================

TEMP_MANIFEST=""

if [ "$MANIFEST_PATH" = "-" ]; then
    log "Reading manifest from stdin..."
    TEMP_MANIFEST="/tmp/wso-manifest-$$.yml"
    cat > "$TEMP_MANIFEST"
    if [ ! -s "$TEMP_MANIFEST" ]; then
        rm -f "$TEMP_MANIFEST"
        die "No manifest content received from stdin"
    fi
    MANIFEST_PATH="$TEMP_MANIFEST"
else
    if [ ! -f "$MANIFEST_PATH" ]; then
        die "Manifest file not found: $MANIFEST_PATH"
    fi
    log "Reading manifest from: $MANIFEST_PATH"
fi

# =============================================================================
# Parse Manifest
# =============================================================================

parse_manifest() {
    if [ "$YQ_TYPE" = "go" ]; then
        yq eval "$1" "$MANIFEST_PATH"
    else
        yq -r "$1" "$MANIFEST_PATH"
    fi
}

MANIFEST_VERSION="$(parse_manifest '.version')"
if [ "$MANIFEST_VERSION" != "2.0" ]; then
    die "Unsupported manifest version: $MANIFEST_VERSION (expected 2.0)"
fi

log "Parsing manifest (version $MANIFEST_VERSION)..."

# Extract service configuration
SERVICE_NAME="$(parse_manifest '.service')"
DATA_UID="$(parse_manifest '.data_uid // 1000')"

[ -z "$SERVICE_NAME" ] || [ "$SERVICE_NAME" = "null" ] && die "service is required"

log "  Service: $SERVICE_NAME"
log "  Data UID: $DATA_UID"

# =============================================================================
# Extract Stack Configuration from Manifest
# =============================================================================

TEMP_STACK_COMPOSE="/tmp/${SERVICE_NAME}-stack-$$.yml"
TEMP_NGINX_CONFIG="/tmp/${SERVICE_NAME}-nginx-$$.conf"
TEMP_CRONTAB="/tmp/${SERVICE_NAME}-crontab-$$.txt"

cleanup() {
    rm -f "$TEMP_STACK_COMPOSE" "$TEMP_NGINX_CONFIG" "$TEMP_CRONTAB" "$TEMP_MANIFEST"
}
trap cleanup EXIT INT TERM

log "Extracting stack configuration from manifest..."

# Extract stack section (required)
if [ "$YQ_TYPE" = "go" ]; then
    yq eval '.stack' "$MANIFEST_PATH" > "$TEMP_STACK_COMPOSE" 2>/dev/null || die "Failed to extract .stack from manifest"
else
    yq -y '.stack' "$MANIFEST_PATH" > "$TEMP_STACK_COMPOSE" 2>/dev/null || die "Failed to extract .stack from manifest"
fi

# Verify stack section exists and is not empty
if [ ! -s "$TEMP_STACK_COMPOSE" ] || grep -q "^null$" "$TEMP_STACK_COMPOSE"; then
    die "stack section is required in manifest"
fi

# Check for unresolved placeholders
if grep -q '{{.*}}' "$TEMP_STACK_COMPOSE"; then
    die "stack section contains unresolved placeholder {{...}}. GitHub Action must substitute all placeholders."
fi

log "  ✓ Stack configuration extracted"

# =============================================================================
# Manage Host Secrets (plain files with root-only permissions)
# =============================================================================

manage_host_secrets() {
    log "Managing host secrets..."

    SECRETS_DIR="/var/lib/wso/secrets"
    if [ ! -d "$SECRETS_DIR" ]; then
        mkdir -p "$SECRETS_DIR" || die "Failed to create $SECRETS_DIR"
        chmod 700 "$SECRETS_DIR"
    fi

    SECRET_COUNT="$(parse_manifest '.secrets | length')"
    if [ "$SECRET_COUNT" = "0" ] || [ "$SECRET_COUNT" = "null" ]; then
        log "  No host secrets defined"
        return 0
    fi

    log "  Found $SECRET_COUNT host secret(s) to manage"

    SECRETS_TEMP="/tmp/wso-secrets-$$.txt"
    parse_manifest '.secrets | to_entries | .[] | .key + "=" + .value' > "$SECRETS_TEMP"

    while IFS='=' read -r secret_name secret_value; do
        [ -z "$secret_name" ] && continue

        if echo "$secret_value" | grep -q '{{.*}}'; then
            rm -f "$SECRETS_TEMP"
            die "Host secret '$secret_name' has unresolved placeholder: $secret_value"
        fi

        SECRET_NAME="${SERVICE_NAME}_${secret_name}"
        SECRET_FILE="${SECRETS_DIR}/${SECRET_NAME}"

        NEW_HASH="$(echo -n "$secret_value" | sha256sum | cut -d' ' -f1)"

        if [ -f "$SECRET_FILE" ]; then
            HASH_FILE="${SECRET_FILE}.hash"
            OLD_HASH=""
            if [ -f "$HASH_FILE" ]; then
                OLD_HASH="$(cat "$HASH_FILE")"
            fi

            if [ "$NEW_HASH" = "$OLD_HASH" ]; then
                log "  ✓ Secret '$SECRET_NAME' unchanged"
                continue
            else
                log "  ↻ Secret '$SECRET_NAME' changed, updating..."
            fi
        else
            log "  + Creating secret '$SECRET_NAME'..."
        fi

        # Write secret to file with root-only permissions
        echo -n "$secret_value" > "$SECRET_FILE" || {
            rm -f "$SECRETS_TEMP"
            die "Failed to save secret to $SECRET_FILE"
        }

        chmod 400 "$SECRET_FILE"
        echo "$NEW_HASH" > "${SECRET_FILE}.hash"
        chmod 400 "${SECRET_FILE}.hash"

        log "  ✓ Secret '$SECRET_NAME' saved"
    done < "$SECRETS_TEMP"

    rm -f "$SECRETS_TEMP"
    log "Host secrets management completed"
}

# =============================================================================
# Generate SSL Certificates
# =============================================================================

generate_ssl_certificates() {
    log "Checking SSL certificates for domains..."

    DOMAINS_COUNT="$(parse_manifest '.domains | length')"

    if [ "$DOMAINS_COUNT" = "0" ] || [ "$DOMAINS_COUNT" = "null" ]; then
        log "  No domains defined, skipping certificate generation"
        return 0
    fi

    log "  Found $DOMAINS_COUNT domain(s)"

    i=0
    while [ $i -lt "$DOMAINS_COUNT" ]; do
        DOMAIN="$(parse_manifest ".domains[$i].domain")"
        CERT_NAME="$(parse_manifest ".domains[$i].cert_name // \"${SERVICE_NAME}_${DOMAIN}\"")"

        if [ -z "$DOMAIN" ] || [ "$DOMAIN" = "null" ]; then
            error "Domain at index $i is empty, skipping"
            i=$((i + 1))
            continue
        fi

        CERT_PATH="${CERT_DIR}/live/${CERT_NAME}/fullchain.pem"

        if [ -f "$CERT_PATH" ]; then
            log "  ✓ Certificate for '$DOMAIN' exists (cert: $CERT_NAME)"
        else
            log "  + Generating certificate for '$DOMAIN' (cert: $CERT_NAME)..."

            if wso-cert-gen "$DOMAIN" "$CERT_NAME"; then
                log "  ✓ Certificate generated successfully"
            else
                die "Failed to generate certificate for '$DOMAIN'"
            fi
        fi

        i=$((i + 1))
    done

    log "SSL certificates check completed"
}

# =============================================================================
# Generate Nginx Configuration
# =============================================================================

generate_nginx_config() {
    log "Generating nginx configuration..."

    if ! sh "${WSO_LIB}/scripts/generate-nginx-config.sh" "$SERVICE_NAME" "$MANIFEST_PATH" "$TEMP_NGINX_CONFIG"; then
        die "Failed to generate nginx configuration"
    fi

    log "  ✓ Nginx configuration generated"
}

# =============================================================================
# Generate Crontab
# =============================================================================

generate_crontab() {
    log "Generating crontab..."

    if sh "${WSO_LIB}/scripts/generate-crontab.sh" "$SERVICE_NAME" "$MANIFEST_PATH" "$TEMP_CRONTAB"; then
        # Check if crontab has content (more than just header)
        if [ -s "$TEMP_CRONTAB" ] && grep -q "^[^#]" "$TEMP_CRONTAB" 2>/dev/null; then
            HAS_CRONTAB=true
            log "  ✓ Crontab generated"
        else
            HAS_CRONTAB=false
            log "  No cron jobs defined"
        fi
    else
        die "Failed to generate crontab"
    fi
}

# =============================================================================
# Deployment
# =============================================================================

log "========================================"
log "WSO Deployment Starting"
log "========================================"
log "Service: ${SERVICE_NAME}"
log "========================================"

# Create service data directory
log "Preparing service data directory..."
SERVICE_DATA_DIR="${DATA_DIR}/${SERVICE_NAME}"
if [ ! -d "$SERVICE_DATA_DIR" ]; then
    mkdir -p "$SERVICE_DATA_DIR" || die "Failed to create $SERVICE_DATA_DIR"
    chown "${DATA_UID}:${DATA_UID}" "$SERVICE_DATA_DIR" || die "Failed to set ownership of $SERVICE_DATA_DIR"
    log "  ✓ Created: $SERVICE_DATA_DIR (owner: ${DATA_UID}:${DATA_UID})"
else
    log "  ✓ Exists: $SERVICE_DATA_DIR"
fi

# Manage host secrets
manage_host_secrets

# Generate SSL certificates
generate_ssl_certificates

# Generate nginx configuration
generate_nginx_config

# Generate crontab
HAS_CRONTAB=false
generate_crontab

# Check if stack exists
STACK_EXISTS=false
if docker stack ls --format '{{.Name}}' | grep -q "^${SERVICE_NAME}$"; then
    STACK_EXISTS=true
    log "Stack exists, performing update..."
else
    log "New stack, performing initial deployment..."
fi

# Skip pre-deployment nginx update (will update after deployment verification)

# Deploy stack
log "Deploying stack..."
if docker stack deploy --with-registry-auth --compose-file "$TEMP_STACK_COMPOSE" "$SERVICE_NAME"; then
    log "  ✓ Stack deployment initiated"
else
    die "Failed to deploy stack"
fi

# Wait for deployment to stabilize with polling
log "Verifying deployment (max 60s wait)..."

MAX_WAIT=60
CHECK_INTERVAL=3
elapsed=0

while [ $elapsed -lt $MAX_WAIT ]; do
    ALL_RUNNING=true
    DEPLOYMENT_FAILED=false
    SERVICES_LIST=$(docker stack services "$SERVICE_NAME" --format '{{.Name}}')

    for svc in $SERVICES_LIST; do
        REPLICAS=$(docker service ls --filter "name=$svc" --format '{{.Replicas}}')

        # Check if service has running replicas
        if echo "$REPLICAS" | grep -qE '^[1-9][0-9]*/[0-9]+'; then
            continue  # Service OK
        fi

        # No running replicas - check latest task state
        LATEST_TASK=$(docker service ps "$svc" --format '{{.CurrentState}}' --filter 'desired-state=running' --no-trunc 2>/dev/null | head -1)

        # Handle empty state (task just created, state not yet available)
        if [ -z "$LATEST_TASK" ]; then
            log "  ⏳ $svc: Initializing... (${elapsed}s/${MAX_WAIT}s)"
            ALL_RUNNING=false
        elif echo "$LATEST_TASK" | grep -qE '(Rejected|Failed)'; then
            error "Service $svc failed: $REPLICAS"
            docker service ps "$svc" --no-trunc --format 'table {{.Name}}\t{{.CurrentState}}\t{{.Error}}' --filter 'desired-state=running' 2>&1 | head -5 >&2
            DEPLOYMENT_FAILED=true
            break
        elif echo "$LATEST_TASK" | grep -qE '(Preparing|Starting|Assigned|Accepted|New|Pending|Allocated)'; then
            log "  ⏳ $svc: $LATEST_TASK (${elapsed}s/${MAX_WAIT}s)"
            ALL_RUNNING=false
        else
            error "Service $svc in unexpected state: '$LATEST_TASK'"
            log "Debug: Run 'docker service ps $svc --no-trunc' for details"
            DEPLOYMENT_FAILED=true
            break
        fi
    done

    if [ "$DEPLOYMENT_FAILED" = "true" ]; then
        die "Deployment failed - service error detected"
    fi

    if [ "$ALL_RUNNING" = "true" ]; then
        log "  ✓ All services running"
        break
    fi

    sleep $CHECK_INTERVAL
    elapsed=$((elapsed + CHECK_INTERVAL))
done

if [ "$ALL_RUNNING" = "false" ]; then
    die "Deployment timeout - services did not start within ${MAX_WAIT}s"
fi

log "Deployment verification completed successfully"

# Update nginx configuration now that services are verified running
log "Updating nginx configuration..."
sh "${WSO_LIB}/scripts/update-nginx-config.sh" "$SERVICE_NAME" "$TEMP_NGINX_CONFIG"

# Install crontab if provided
if [ "$HAS_CRONTAB" = true ]; then
    log "Installing crontab..."
    CRON_FILE="/etc/cron.d/${SERVICE_NAME}"

    # Verify crontab syntax before installing
    if ! crontab -n "$TEMP_CRONTAB" 2>&1 | grep -q "successfully checked"; then
        crontab -n "$TEMP_CRONTAB" 2>&1 | head -5 >&2
        die "Invalid crontab syntax generated for $SERVICE_NAME"
    fi

    CRONTAB_CHANGED=false

    if [ -f "$CRON_FILE" ]; then
        OLD_HASH="$(sha256sum "$CRON_FILE" | cut -d' ' -f1)"
        NEW_HASH="$(sha256sum "$TEMP_CRONTAB" | cut -d' ' -f1)"

        if [ "$OLD_HASH" = "$NEW_HASH" ]; then
            log "  ✓ Crontab unchanged"
        else
            log "  ↻ Crontab changed, updating..."
            cp "$TEMP_CRONTAB" "$CRON_FILE" || die "Failed to install crontab"
            chmod 644 "$CRON_FILE"
            CRONTAB_CHANGED=true
            log "  ✓ Crontab updated"
        fi
    else
        log "  + Installing new crontab..."
        cp "$TEMP_CRONTAB" "$CRON_FILE" || die "Failed to install crontab"
        chmod 644 "$CRON_FILE"
        CRONTAB_CHANGED=true
        log "  ✓ Crontab installed"
    fi

    # Reload cron service if crontab changed (restart if reload not supported)
    if [ "$CRONTAB_CHANGED" = true ]; then
        if systemctl is-active --quiet cron 2>/dev/null; then
            systemctl reload cron 2>/dev/null || systemctl restart cron
        elif systemctl is-active --quiet cronie 2>/dev/null; then
            systemctl reload cronie 2>/dev/null || systemctl restart cronie
        fi
        log "  ✓ Cron service reloaded"
    fi
fi

log "========================================"
log "Deployment Completed Successfully"
log "========================================"
log "Service: ${SERVICE_NAME}"
log ""
log "Useful commands:"
log "  docker stack services ${SERVICE_NAME}"
log "  docker stack ps ${SERVICE_NAME} --no-trunc"
log "  docker service logs -f ${SERVICE_NAME}_<service>"
log "  docker stack rm ${SERVICE_NAME}"
log ""
log "Host secrets (plain files, namespaced as ${SERVICE_NAME}_*):"
log "  ls -la /var/lib/wso/secrets/${SERVICE_NAME}_*"
log "  sh /usr/lib/wso/scripts/cat-global-secret.sh ${SERVICE_NAME} <secret_name>"
if [ "$HAS_CRONTAB" = true ]; then
    log ""
    log "Crontab:"
    log "  cat /etc/cron.d/${SERVICE_NAME}"
fi
log "========================================"
